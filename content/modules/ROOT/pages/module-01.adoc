= Establish Trust With SBOM Validation

== Overview

In this module, you establish the foundation of the *Trusted Software Supply Chain (TSSC)*. Before securing builds or enforcing policy, you need a central, verifiable source of truth for software composition, which is why you will deploy *Red Hat Trusted Profile Analyzer (RHTPA)* and configure it to ingest Software Bills of Materials (SBOMs).

== Step 1: Configure Identity and Access Management

*RHTPA* requires an external *OpenID Connect (OIDC)* provider for authentication and authorisation, as it does not maintain its own internal user store. In this module, you will integrate *RHTPA* with *Red Hat Build of Keycloak (RHBK)*, which issues the tokens and identity claims that *RHTPA* ruses to validate users and permissions.

Access control is enforced through *Role-Based Access Control (RBAC)* defined in *RHBK*. Roles define what a user or service is allowed to do, while client scopes define the token claims the *RHTPA* backend evaluates before processing an operation.

You will import a pre-configured *realm* that defines the two clients:

. *Frontend*: Used by human users accessing the *RHTPA* web interface.
. *CLI*: Used by CI/CD systems, such as *Tekton* or *Jenkins*, to upload *SBOMs* programmatically. TThis client uses a service account for machine-to-machine authentication.

[NOTE]
====
*Key Concepts: Realm and Client Scope*

* *Realm*: A realm is an isolated security domain that manages its own users, groups, roles and client configurations. In this workshop, the *tpa* realm contains the roles and client mappings required for *RHTPA* to validate incoming requests.

* *Client Scope*: A client scope represents specific permissions encoded into an access token. Roles define who a user is; scopes define what the user is authorised to do. The *RHTPA* backend checks these scopes when processing API requests.
====

Log in to the RHBK console to review existing using the following details:

* *RHBK Console URL*:{keycloak_admin_console}[*URL*, ,window=_blank] 
* *Username*: {keycloak_admin_user}
* *Password*: {keycloak_admin_password}
* After entering your credentials, you click the *Sign In*.

In the RHBK Console click on the "Manage Realm" link in the left navigation menu, you will notice that we have to realms already configured *master* and *sso* as you can see in this screenshot

In the left navigation menu, select *Manage Realm*. You will see the existing realms, *master* and *sso*, as shown below:

image::keycloak_manage_realms.png[Keycloak Realms,align="center"]


=== Import the TPA Realm

Before importing the *tpa* realm, switch to the OpenShift Console to monitor the realm import job.
Click the *OpenShift Console* tab in the Showroom:

image::showroom_openshift_console.png[Showroom OpenShift Console,align="center"]

Expand the Ecosystem list in the left Navigation menu and select *Installed Operators*, input "keycloak" in the name filter, and select the Red Hat build of Keycloak Operator link.

From the left navigation menu, expand *Ecosystem* and select *Installed Operators*.
Filter by “Keycloak” and select *Red Hat Build of Keycloak Operator*.

image::keycloak_operator.png[Keycloak Operator ,align="center"]

Then select the *KeycloakRealmImport* tab.
At this stage, no import jobs are running. You will trigger the import in the next step.

image::keycloak_realmimport.png[Keycloak Realm Import,align="center"]

 Run the following command in the ShowRoom terminal to apply the configuration in the "keycloak-tpa-realm.yml" yaml file and import the new *tpa* realm configuration to the *tssc-keycloak* namespace.

image::showroom_terminal.png[Keycloak Realm Import,align="center"]

+
[source,role="execute"]
----
export TPA_REALM={tpa_realm}
export TPA_CLI_CLIENT_SECRET={tpa_cli_client_secret}
export TPA_ADMIN_USERNAME={tpa_admin_username}
export TPA_ADMIN_PASSWORD={tpa_admin_password}
export KEYCLOAK_URL={keycloak_admin_console}
envsubst '${TPA_REALM} ${TPA_CLI_CLIENT_SECRET} ${TPA_ADMIN_USERNAME} ${TPA_ADMIN_PASSWORD}' < ~/lab-assets/keycloak-tpa-realm.yml | oc apply -n tssc-keycloak -f -
----

Switch back to the *KeyCloakRealmImport* tab. You will see that the import job has started:

image::tpa_realm_import_start.png[TPA Realm Import Start,align="center"]

After a short time, the status will change to *Done*.

What just happened? The YAML you just applied defines roles and scopes used by the *RHTPA* evaluates when authorising user and pipeline actions:

* Roles created:
. *tpa-user*: Read-only access.
. *tpa-manager*: Create and delete documents.
. *tpa-admin*: Full administrative access.

* Scopes created:
. *create:document*: Required to upload an SBOM. Included for tpa-manager and tpa-admin.
. *read:document*: Required to view dashboards and search data. Included for tpa-user.
. *delete:document*: Required to delete SBOMs. Included only for administrators.

Scopes are mapped to roles so that *RHBK* automatically includes the correct permissions in the access token.
For example, a user with the *tpa-manager* role receives the create:document scope, allowing them to upload SBOMs via CLI or UI.

Return to the *Manage Realm* view in the *RHBK* console and select the newly created *tpa* realm:

image::tpa_realm.png[New TPA Realm,align="center"]

WARNING: When a new realm is imported, *RHBK* restarts to refresh its configuration. During this time, you may briefly see *Application is not available* error when try to access the *RHBK* console.

Navigate to *Clients* in the left menu.
You will see the two clients created by the import: *cli* and *frontend*.

image::tpa_realm_clients.png[TPA Realm Clients,align="center"]

You can continue exploring the client scopes and realm roles before proceeding to the next section, where you will deploy the RHTPA instance.



=== Create the RHTPA Instance

Before the *RHTPA* application can start, it must be configured to trust the Identity Provider (IdP). This requires creating a Kubernetes Secret that contains the OIDC Client ID and Client Secret used by the *CLI* client.

* Run the following command to create the CLI credentials Secret

+
[source,role="execute"]
----
envsubst < ~/lab-assets/tpa-cli-credentials.yml | oc apply -n tssc-tpa -f -
----

With the credentials in place, you can now deploy the *RHTPA* instance using its Custom Resource (CR).
This CR acts as the application blueprint and instructs the *RHTPA Operator* to deploy the following components:
1. API Server: The backend service responsible for request handling.
2. UI: The web dashboard used for browsing, querying and managing SBOM data.
3. Ingestion & Analysis: Components responsible for SBOM ingestion, persistence in PostgreSQL and processing by the intelligence engine.

* Run the following command to apply the *RHTPA* Instance CR:

+
[source,role="execute"]
----
envsubst < ~/lab-assets/tpa-instance.yml | oc apply -n tssc-tpa -f -
----

Switch to the OpenShift Console tab in your Showroom.
Navigate to: Operators → Installed Operators,then filter by Profile Analyzer and select the TrustedProfileAnalyzer entry under Provided APIs.

image::tpa_operator.png[TPA Operator,align="center"]

Wait for the *RHTPA* instance to progress to a deployed successfully state.

image::tpa_operator.png[TPA Operator,align="center"]

You can also verify the deployment at the pod level.
Navigate to: Workloads → Pods and confirm that the *RHTPA* server pod is running.

image::tpa_operator.png[TPA Operator,align="center"]

===  Ingest an SBOM

We will now simulate what a CI/CD pipeline does during a build: uploading an SBOM via the API. This verifies that our "machine-to-machine" authentication is working correctly.

NOTE: {explain what an SBOM is}

Run the following command to extract the RHTPA server URL

+
[source,role="execute"]
----
export TPA_SERVER_URL="https://$(oc get route -l app.kubernetes.io/component=server -n tssc-tpa -o json \
  | jq -r '.items[0].spec.host')"
----

 We need request a token from Keycloak using the client_credentials grant type. This is the standard OAuth2 flow for automated services (like Tekton).
 Obtain an Access Token by running the following command:

+
[source,role="execute"]
----
TOKEN_EP=$(curl "$KEYCLOAK_URL/realms/$TPA_REALM/.well-known/openid-configuration" | jq -r .token_endpoint)
TOKEN=$(curl -s -X POST "$TOKEN_EP" \
  -d grant_type=client_credentials \
  -d client_id="cli" \
  -d client_secret="$TPA_CLI_CLIENT_SECRET" | jq -r .access_token)
----

 You will now POST the SBOM file to the API, passing the token in the header.
 Upload the SBOM by running the following command:

+
[source,role="execute"]
----
curl -X POST ${TPA_SERVER_URL}/api/v2/sbom?id=test-sbom  -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" --data-binary @/home/lab-user/lab-assets/example-sbom.json
----

Verification: A successful upload returns a JSON object with a UUID, e.g., {"id":"urn:uuid:..."}. This confirms the API accepted the file and the OIDC scopes (create:document) were correctly enforced.

Note: You are manually testing the cli client credentials now, but in Module 2, this exact client configuration is what Tekton Chains will use to automatically push SBOMs during the build pipeline.

===  View the SBOM from RHTPA UI