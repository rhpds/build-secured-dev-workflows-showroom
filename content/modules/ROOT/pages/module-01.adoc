= Establish Software Composition Trust with SBOMs

== Overview

* In this module, you establish the foundation of the *Trusted Software Supply Chain (TSSC)*. 
* Before securing builds or enforcing policy, organisations need a central, verifiable source of truth for software composition.
* To achieve this, you will deploy *Red Hat Trusted Profile Analyzer (RHTPA)* and configure it to ingest Software Bills of Materials (SBOMs), creating an auditable inventory of what is included in every build.

== Step 1: Configure Identity and Access Management

* *RHTPA* requires an external *OpenID Connect (OIDC)* provider for authentication and authorization, as it does not maintain its own internal user store.
* In this module, you will integrate *RHTPA* with *Red Hat Build of Keycloak (RHBK)*,  which is responsible for issuing identity tokens and embedding the claims and permissions that *RHTPA* evaluates when processing API and UI requests.
* In this configuration, access control is implemented using *Role-Based Access Control (RBAC)* defined in *Red Hat Build of Keycloak (RHBK)*.
* Roles describe who a user or service is, while client scopes define what actions are permitted.
* *RHTPA* does not evaluate roles directly. Instead, it authorizes requests by checking for specific scopes embedded in the OIDC access token.
* In this step, you will import a pre-configured *realm* that defines the two clients:
. *Frontend*: Used by human users accessing the *RHTPA* web interface.
. *CLI*: Used by CI/CD systems, such as *Tekton* or *Jenkins*, to upload *SBOMs* programmatically. This client uses a service account for machine-to-machine authentication.

[NOTE]
====
*Key Concepts: Realm and Client Scope*

* *Realm*: A realm is an isolated security domain that manages its own users, groups, roles and clients. In this workshop, the *tpa* realm contains the identity configuration that *RHTPA* trusts when validating incoming requests.

* *Client Scope*: A client scope represents specific permissions encoded into an access token. While roles are assigned to users or service accounts, scopes are what the *RHTPA* backend checks to authorize API operations such as uploading or reading SBOMs.
====

* Click the *RHBK Console* tab in the Showroom.
* Log in to the RHBK console using the following details:

* *Username*:

[source, role="execute", subs="attributes"]
----
{keycloak_admin_user}
----

* *Password*:

[source, role="execute", subs="attributes"]
----
{keycloak_admin_password}
----

* After entering your credentials, click the *Sign In* button.
* In the *RHBK Console* click on the "Manage Realm" link in the left navigation menu, you will notice that we have two realms already configured *master* and *sso* as you can see in this screenshot

image::keycloak_manage_realms.png[Keycloak Realms,align="center"]

[#importtparealm]
=== Import the TPA Realm

* Before importing the *tpa* realm, switch to the OpenShift Console to monitor the realm import job.
* Click the *OpenShift Console* tab in the Showroom

Log in to the OpenShift console using the following details:

* *Username*: 

[source, role="execute", subs="attributes"]
----
{openshift_gitops_admin_user}
----

* *Password*:

[source, role="execute", subs="attributes"]
----
{openshift_gitops_admin_password}
----

* After entering your credentials, click the *Sign In* button.

image::showroom_openshift_console.png[Showroom OpenShift Console,align="center"]

* Expand the Ecosystem list in the left Navigation menu and select *Installed Operators*
* In the name filter input: 

[source, role="execute", subs="attributes"]
----
keycloak
----

* Select the Red Hat build of *Keycloak Operator* link.

* From the left navigation menu, expand *Ecosystem* and select *Installed Operators*.
* Filter by “Keycloak” and select *Red Hat Build of Keycloak Operator*.

image::keycloak_operator.png[Keycloak Operator ,align="center"]

* Then select the *KeycloakRealmImport* tab.
* At this stage, no import jobs are running. You will trigger the import in the next step.

image::keycloak_realmimport.png[Keycloak Realm Import,align="center"]

* Execute the following command in the ShowRoom terminal to set the required variables for this module.

image::showroom_terminal.png[Keycloak Realm Import,align="center"]

* Set the required variables

[source, role="execute", subs="attributes"]
----
cat << 'EOF' >> ~/.bashrc
export TPA_REALM={tpa_realm}
export TPA_CLI_CLIENT_SECRET={tpa_cli_client_secret}
export TPA_ADMIN_USERNAME={tpa_admin_username}
export TPA_ADMIN_PASSWORD={tpa_admin_password}
export KEYCLOAK_URL={keycloak_admin_console}
EOF
source ~/.bashrc
----

* Execute the following command to apply the configuration in the *keycloak-tpa-realm.yml* and import the new *tpa* realm configuration to the *tssc-keycloak* namespace.

[source, role="execute"]
----
envsubst '${TPA_REALM} ${TPA_CLI_CLIENT_SECRET} ${TPA_ADMIN_USERNAME} ${TPA_ADMIN_PASSWORD}' < ~/lab-assets/keycloak-tpa-realm.yml | oc apply -n tssc-keycloak -f -
----

* Switch back to the *KeyCloakRealmImport* tab in the *OpenShift console*. You will see that the import job has started:

image::tpa_realm_import_start.png[TPA Realm Import Start,align="center"]

* After a short time, the status will change to *Done*.

=== What just happened?

* The YAML you applied creates the identity- and authorization-model that *Red Hat Trusted Profile Analyzer (RHTPA)* uses to control SBOM upload, search, and deletion.
* It created:
. Client scopes that act as concrete API permissions
. Realm roles used to assign high-level identity
. Scope mappings that attach permissions to roles

==== 1. Client scopes created

RHTPA authorises API calls using OIDC scopes, not Keycloak role names.
Those scopes are defined here:

[source]
----
clientScopes:
  - name: create:document
  - name: read:document
  - name: delete:document
----

* These map directly to operations in the RHTPA APIs:
. *read:document*: required to query SBOMs, load dashboards, or list inventory.
. *create:document*: required to upload an SBOM (human CLI or Tekton pipeline).
. *delete:document*: required to remove previously uploaded SBOMs.
* If a user or pipeline identity calls the API without the required scope, RHTPA denies the request.

==== 2. Roles created:

* In the YAML, the roles block defines three realm roles:

[source]
----
roles:
  realm:
    - name: tpa-user
    - name: tpa-manager
    - name: tpa-admin
----

* These roles do not grant permission by themselves — they are labels that a human user or a Tekton machine identity can be assigned.

==== 3. Scope-to-role mapping

* The next YAML block maps those scopes to specific roles so that when a user logs in, the access token carries the correct permissions:

[source]
----
scopeMappings:
  - clientScope: read:document
    roles: [ tpa-user, tpa-manager, tpa-admin ]
  - clientScope: create:document
    roles: [ tpa-manager, tpa-admin ]
  - clientScope: delete:document
    roles: [ tpa-admin ]
----

* These mappings result in three effective permissions levels
. *tpa-user* → read only
. *tpa-manager* → read + create
. *tpa-admin* → read + create + delete

* RHBK is responsible for issuing these scopes in the token.
* RHTPA is responsible for interpreting them and enforcing which operations are allowed.
* For example when we assign the tpa-manager role to Tekton's service account, the the resulting OIDC token automatically contains:

[source]
----
"scope": "openid email profile create:document read:document"
----

* That token is sent to RHTPA with the SBOM upload API call.
. If create:document is present — upload succeeds.
. If it is missing — RHTPA rejects the request with 403.



* Refresh the *RHBK console* in *Showroom*
* Return to the *Manage Realm* view in the *RHBK* console and select the newly created *tpa* realm:

image::tpa_realm.png[New TPA Realm,align="center"]

WARNING: When a new realm is imported, *RHBK* restarts to refresh its configuration. During this time, you may briefly see *Application is not available* error when try to access the *RHBK* console.

* Navigate to *Clients* in the left menu.
* You will see the two clients created by the import job: *cli* and *frontend*.

image::tpa_realm_clients.png[TPA Realm Clients,align="center"]

* You can continue exploring the client scopes and realm roles before proceeding to the next section, where you will deploy the RHTPA instance.


[#createrhtpainstance]
== Step 2: Create the RHTPA Instance

Before the *RHTPA* application can start, it must be configured to trust the Identity Provider (IdP). This requires creating a Kubernetes Secret that contains the OIDC Client ID and Client Secret used by the *CLI* client.

* Run the following command in the showroom terminal to create the CLI credentials Secret

[source,role="execute"]
----
envsubst < ~/lab-assets/tpa-cli-credentials.yml | oc apply -n tssc-tpa -f -
----

* With the credentials in place, you can now deploy the *RHTPA* instance using its Custom Resource (CR).
* The Custom Resource defines the desired state of the *RHTPA* deployment and instructs the *RHTPA Operator* to provision:
. API Server: Handles authenticated API requests and enforces scope-based authorization.
. Web UI: The web dashboard used for browsing, querying and managing SBOM data.
. Ingestion & Analysis Services: Components responsible for ingesting SBOM, persisting in PostgreSQL and correlate SBOMs with vulnerability intelligence as importer data becomes available.

* Run the following command to apply the *RHTPA* Instance CR:

[source,role="execute"]
----
envsubst < ~/lab-assets/tpa-instance.yml | oc apply -n tssc-tpa -f -
----

* Switch to the OpenShift Console tab in your Showroom.
* Select the project:

[source,role="execute"]
----
tssc-tpa
----

image::select_tssc-tpa_project.png[Select tssc-tpa project,align="center"]

* Navigate to: Workloads → Pods and confirm that the *RHTPA* server pod is running. The pod name will follow the format *server-<hash>*.

image::tpa_server_pod.png[TPA Server Pod,align="center"]

[#ingestansbom]
== Step 3: Ingest an SBOM

=== What is an SBOM anyway?

* A Software Bill of Materials (SBOM) is a machine-readable inventory that describes the components, libraries, and dependencies included in a software artifact.
* SBOMs provide the factual basis for understanding what is inside an application and are a prerequisite for supply chain risk analysis.
* In this step, you simulate what a CI/CD pipeline does during a build: you will authenticate using the client_credentials OAuth 2.0 grant.
* This is the same machine-to-machine authentication flow used by automated systems such as Tekton to upload SBOMs during a build.
* In the Showroom terminal, run the following command to extract the external route for the RHTPA server:

[source,role="execute"]
----
export TPA_SERVER_URL="https://$(oc get route -l app.kubernetes.io/component=server -n tssc-tpa -o json \
  | jq -r '.items[0].spec.host')"
----

* The cli client uses the client_credentials grant type to authenticate. This is the standard OAuth2 flow for non-interactive workloads such as Tekton, Jenkins or GitHub Actions.
 
* Run the following commands to discover the token endpoint and obtain an access token:

[source,role="execute"]
----
TOKEN_EP=$(curl "$KEYCLOAK_URL/realms/$TPA_REALM/.well-known/openid-configuration" | jq -r .token_endpoint)
TOKEN=$(curl -s -X POST "$TOKEN_EP" \
  -d grant_type=client_credentials \
  -d client_id="cli" \
  -d client_secret="$TPA_CLI_CLIENT_SECRET" | jq -r .access_token)
----

* Use the token to POST an SBOM file to the ingestion API:

[source,role="execute"]
----
curl -X POST ${TPA_SERVER_URL}/api/v2/sbom?id=test-sbom  -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" --data-binary @/home/lab-user/lab-assets/example-sbom.json
----

* A successful upload returns a JSON payload containing a UUID, for example: {"id":"urn:uuid:..."}. 
* This confirms three things:
. Authentication via OIDC is functioning.
. Scope-based authorization is correctly enforced.
. The SBOM ingestion pipeline is operational.

NOTE: You are manually exercising the cli client credentials here.
In Module 2, Tekton Chains will use this same client configuration to automatically push SBOMs during the build pipeline.

[#viewsbom]
== Step 4:  View the SBOM from RHTPA UI

* Click the *RHTPA Console* tab in the Showroom, you may need to refresh the tab.

image::showroom_rhtpa_console.png[RHTPA Console,align="center"]

Log in to the RHTPA console using the following details:

* *Username*:

[source, role="execute", subs="attributes"]
----
{tpa_admin_username}
----

* *Password*:

[source, role="execute", subs="attributes"]
----
{tpa_admin_password}
----

* After entering your credentials, click the *Sign In* button.
* Once logged in, check the dashboard. You should see *test-sbom* listed in the inventory.
* Click on the SBOM link to view it's details.

image::view_test_sbom.png[View Test SBOM,align="center"]

[NOTE]
====
Why is the vulnerability report empty? If the test-sbom entry shows 0 vulnerabilities, or the dependency graph appears empty, this is expected behavior for a fresh installation. 
Reason: RHTPA relies on background importer jobs to download large advisory datasets (NVD, GitHub Advisories and others). These datasets must be fully synced before the system can correlate vulnerabilities to SBOM components. The first sync can take a significant amount of time, especially in new environments.
====


===  Module 1 Summary

* By completing this module, you configured identity in *RHBK*, deployed *RHTPA* and validated your first SBOM—establishing a reliable source of truth for software composition. This is a great starting point for consultants to to implement early-stage in real customer environments.
* For technical sellers, when a customer says, “We cannot verify or attest to the components that make up our software,” you now know exactly where to start. RHTPA gives customers an auditable view of their software composition, enabling risk assessment from the very first stage of the software delivery process.
* And now that we know what is in our software, the next question naturally follows: “How do we know these artifacts haven’t been tampered with?” That is the next trust boundary we will solve.
* Head to Module 2 to learn how to cryptographically sign and verify artifacts using *Red Hat Trusted Artifact Signer (RHTAS)*, ensuring every image you build can be traced, trusted and validated.




