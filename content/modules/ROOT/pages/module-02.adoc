= Module 2: Sign and Verify All Artifacts With *RHTAS* 

== Introduction 

* In Module 1, you established trust in what is inside your software. The next challenge customers face is: “How do we know these artifacts were really built by us and haven’t been tampered with?” 
* They need assurance that both code commits and build artifacts originate from trusted sources—not rogue machines or compromised pipelines.


=== Enter Red Hat Trusted Artifact Signer (RHTAS) 

* In this module, you will deploy *RHTAS* to establish the Root of Trust for the entire build system.
* *RHTAS* is an enterprise deployment of the *Sigstore* project. 
* It provides cryptographic signing, verification, provenance attestation and transparency, ensuring software artifacts can be proven authentic at every stage of delivery. 
* It supports keyless signing via OIDC, and also key-based workflows when required in tightly controlled environments.

=== RHTAS component overview

* Architecturally, RHTAS combines Sigstore components to deliver identity-based, auditable signing:
. *Fulcio*: a certificate authority (CA) that issues short-lived X.509 signing certificates bound to an authenticated OpenID Connect (OIDC) identity, such as a Keycloak user or service account.
. *Rekor*: a transparency log that records signatures, certificates and attestations in an append-only, tamper-evident log. It allows anyone to independently verify that a signing event occurred.
. *Trillian*: the cryptographic storage engine behind *Rekor*. It organizes log entries in a *Merkle tree* so that every entry is provably recorded and cannot be removed or altered without detection.
. *TUF (The Update Framework)*: Manages the root keys and trust metadata that the signing system relies on. TUF ensures clients know which public keys and certificates are legitimate, providing a cryptographic “root of trust” when verifying signatures from *Rekor* or certificates from *Fulcio*.
. *Cosign*: A CLI used to sign and verify signed artifacts. Pipelines (Tekton Chains) invoke cosign to generate signatures and publish them to the image registry and Rekor.

NOTE: A *Merkle tree* is a data structure where each entry is represented by a hash, and those hashes are combined up a tree — meaning a single “root hash” represents the entire log. If anyone tries to change or delete an entry, the hashes won’t match anymore, so the tampering is immediately visible.

* Together, these components establish an auditable chain of trust across container images, code commits and other artifacts. Every signature is tied to a real identity, recorded in a transparency log and verifiable against a well-defined trust root.

=== How does keyless signing work?
*  Traditional signing models rely on long-lived private keys that developers or CI systems must generate, store, rotate and protect. In contrast, RHTAS uses keyless signing and short lived certificates. The following explains the flow for image signing:
. Tekton finishes building and pushing a container image
** A pipeline task builds and pushes an image to a registry such as Quay.io.
** At this point, the image exists, but has no provenance or cryptographic signature.
** Chains watches the cluster for completed TaskRuns.
** When it detects a success event, it issues a signing request to Cosign.
. Cosign initiates an OIDC-based identity request
** To perform keyless signing, Cosign must obtain an OIDC identity token from the configured identity provider (RHBK in this workshop).
** Cosign authenticates using the Kubernetes service account identity that Tekton Chains is running under.
** Cosign performs a standard OIDC authentication flow and receives a JWT identity token that includes claims such as email (the identity), issuer (RHBK), expiry timestamp, and audience (Fulcio).
. Cosign requests a signing certificate from Fulcio
** Cosign sends the OIDC identity token to Fulcio and asks for a certificate.
** Fulcio validates that:
*** the token came from a trusted issuer
*** an email claim (identity) is present and verified
*** the signature on the token is valid and has not expired
** If validation succeeds, Fulcio issues a short-lived X.509 certificate bound to that identity.
. Cosign prepares to create a singing event for the Trust Authority (Rekor + Trillian)
** Cosign generates signs the image digest
** Cosign creates a one-time signing key in memory only and pairs it with the Fulcio certificate.
** Cosign signs the image digest (not the image file) and produces a cryptographic signature.
** Cosign submits the signing event to the transparency log (Rekor + Trillian)
** Cosign forwards the signature, the certificate chain and associated metadata to Rekor.
** Rekor stores the record in a tamper-evident Merkle-tree (backed by Trillian) and returns an inclusion proof.
** This guarantees the signing event cannot be hidden or rewritten.
. Cosign pushes the signature to the OCI registry
** Cosign pushes a separate OCI artefact containing the signature and certificate alongside the original image tag (for example :latest).

image::keyless_signing_flow.png[keyless_signing_flow,align="center"]

NOTE: In an interactive keyless signing flow (for example, when signing code from your IDE), Cosign will prompt you to authenticate with the OIDC provider, such as RHBK in this workshop. It prints a login URL (and sometimes a short verification code), you complete the login in your browser, and provide the OIDC access token to Cosign, which behind the scenes requests a signing certificate from Fulcio.  


== 1: Configure the Machine Identity

* Tekton Chains requires its own realm and client to sign images on behalf of the pipeline.
* This isolates automated signing from human user identities and is considered best practice in customer deployments.

=== Step 1: Create tas-chains realm and tas client

* If you are not already logged in to RHBK, click the RHBK Console tab in the Showroom and log in using:

* *Username*:

[source, role="execute", subs="attributes"]
----
{keycloak_admin_user}
----

* *Password*:

[source, role="execute", subs="attributes"]
----
{keycloak_admin_password}
----

* After entering your credentials, click *Sign In*.

* In the *RHBK Console*, click *Manage Realm*  in the left navigation menu.
* Click the *Create realm* button.

image::create_tas_realm.png[Create Realm,align="center"]

* In the *Create realm* pop up, enter the *Realm name*:

[source, role="execute", subs="attributes"]
----
tas-chains 
----

* Click *Create*.

image::create_tas_chains_realm.png[Create TAS Chains realm,align="center"]

* Next you you will create a new client, in the left navigation menu, click *Clients*, then click *Create client*.

image::create_client.png[Create Client,align="center"]

* In the *General setting* page:
* Set the *Client ID* to:

[source, role="execute", subs="attributes"]
----
trusted-artifact-signer
----

* Click *Next*.

image::tas_client_general_settings.png[New Client General Settings,align="center"]

* Under *Capability Config*, set:
. *Client authentication*: toggle on
. *Standard flow*: make sure this checkbox is ticked
. *Service accounts* roles: Tick this checkbox
* Then click *Next*.

image::tas_client_capability_config.png[New Client Capability Config,align="center"]

* Under *Login Settings*, leave the default values as they are.
* Click *Save*.

image::tas_client_login_settings.png[New Client Login Settings,align="center"]

* Scroll down to *Logout Settings*:
. Make sure *Front channel logout* is toggled on.
. Click *Save*.

image::tas_client_logout_settings.png[New Client Logout Settings,align="center"]

* Scroll back up to top of the screen, and click the *Service account roles* tab 
* Click the *service-account-trusted-artifact-signer* link

image::tas_client_service_account_roles.png[New Client Service Account Roles,align="center"]

* Set the following attributes:
* *Email Verified*: toggle on
* *Email*: 

[source, role="execute", subs="attributes"]
----
trusted-artifact-signer@demo.redhat.com
----

*.* *First name*:

[source, role="execute", subs="attributes"]
----
Trusted
----

* *Last name*: 

[source, role="execute", subs="attributes"]
----
Content
----

* The click *Save*

image::tas_client_service_account_details.png[New Client Service Account Roles,align="center"]

WARNING: This is the most common failure point in RHTAS deployments. Fulcio requires the OIDC token to contain a verified email claim. If this is missing, certificate issuance fails.

=== Step 2: Configure Developer Identity for Commit Signing

* Developers need a trusted identity to sign *Git* commits using *RHTAS*.
* This identity is separate from Tekton’s machine identity you configured in the last step and is configured in the existing sso realm.
* The client you create here enables OAuth-based authentication for developers performing commit signing.

* In the *RHBK Console*, click *Manage Realm* in the left navigation menu.
* Select the *sso* realm.

image::tas_sso_realm.png[TAS SSO Realm,align="center"]

* Navigate to *Clients* in the left menu and click *Create client*.

image::tas_create_client.png[TAS Create Client,align="center"]

* In the *General setting* page:
. Set the *Client ID* to:

[source, role="execute", subs="attributes"]
----
trusted-artifact-signer
----

. Click *Next*.

image::tas_client_general_settings.png[New Client General Settings,align="center"]

* Under Capability Config set:
. *Standard flow*: Make sure this checkbox is ticked.
. *Direct Access Grants*: Tick this checkbox.
* Then click *Next*.

image::tas_commit_client_capability_config.png[New Client Capability Config,align="center"]

* In the *Login Settings* page, add the following *Valid Direct URIs*:
. Add the first URI: 

[source, role="execute", subs="attributes"]
----
urn:ietf:wg:oauth:2.0:oob
----

. Click *Add valid redirect URIs*, then input:

[source, role="execute", subs="attributes"]
----
*
----

* Click *Save*
* This allows tools like *RHTAS* to complete the OAuth authentication flow.

image::tas_commit_client_client_login_settings.png[New Client Login Settings,align="center"]

* Now scroll down to the *Logout settings* section and set the *Front channel logout* toggle to *Off*. 
* Then click *Save*

image::tas_commit_client_logout_settings.png[New Client Logout Settings,align="center"]


=== Step 3: Deploy the RHTAS Instance

Now that both machine and developer identities are configured, you can deploy the RHTAS components (Fulcio, Rekor, Trillian and TUF) using the Custom Resource.

* Run the following command to apply the *RHTAS* Instance CR:

[source, role="execute", subs="attributes"]
----
cat << 'EOF' >> ~/.bashrc
export TAS_CHAINS_CLIENT_ID={tas_chains_client_id}
export TAS_CHAINS_REALM={tas_chains_realm}
export TAS_SSO_REALM={tas_sso_realm}
EOF
source ~/.bashrc
envsubst < ~/lab-assets/tas-instance.yml | oc apply -n tssc-tas -f -
----

* Verify Deployment Readiness
. Switch to the *OpenShift console*
. Navigate to *Workloads → Pods*
. Change the project/namespace to:

[source, role="execute", subs="attributes"]
----
tssc-tas
----

* Wait until the tuf pod is in Running state.

image::tas_verify_deploy.png[Verify RHTAS deploy,align="center"]

== Step 4: Deploy The OIDC Refresher App 

* In this step you will deploy a small helper application that continuously refreshes the OIDC token required for signing.

===  Why is the OIDC Refresher App needed?

* Fulcio issues short-lived certificates based on OIDC tokens.
* For security reasons, these tokens typically expire within 5 minute
* However, a CI/CD pipeline (such as a Tekton build) may run for 20 minutes or more before reaching the Sign Image step.
* If Tekton Chains attempts to sign an image using the token obtained at pipeline start, that token will almost certainly have expired.
* To solve this, you will deploy the OIDC Refresher App which does the following:
. Authenticates with Keycloak using the trusted-artifact-signer client credentials you created in Step 1.
. Fetches a fresh access token.
. Writes the token into a Kubernetes Secret named oidc-token in the openshift-pipelines namespace.
. Refreshes the token every 2 minutes, ensuring Tekton always signs using a valid identity.

===  Deploy OIDC Refresher App

* First, retrieve the Keycloak admin credentials from the keycloak-initial-admin secret in the tssc-keycloak namespace:

[source, role="execute", subs="attributes"]
----
export keycloak_admin_user=$(oc get secret keycloak-initial-admin -n tssc-keycloak -o jsonpath='{.data.username}' | base64 -d)
export keycloak_admin_password=$(oc get secret keycloak-initial-admin -n tssc-keycloak -o jsonpath='{.data.password}' | base64 -d)
----

* Next, use the credentials to request an admin access token:

[source, role="execute", subs="attributes"]
----
KEYCLOAK_ACCESS_TOKEN=$(curl -s -X POST "${KEYCLOAK_URL}/realms/master/protocol/openid-connect/token" \
-H "Content-Type: application/x-www-form-urlencoded" \
-d "client_id=admin-cli" \
-d "username=$keycloak_admin_user" \
-d "password=$keycloak_admin_password" \
-d "grant_type=password" | jq -r '.access_token')
----

* Next, retrieve the client secret for the trusted-artifact-signer client from the tas-chains realm:

[source, role="execute", subs="attributes"]
----
export TAS_CHAINS_CLIENT_SECRET=$(curl -s -X GET "${KEYCLOAK_URL}/admin/realms/$TAS_CHAINS_REALM/clients?clientId=$TAS_CHAINS_CLIENT_ID" \
  -H "Authorization: Bearer $KEYCLOAK_ACCESS_TOKEN" | jq -r '.[0].secret')
----

* Finally, create the Kubernetes Secret containing the OIDC configuration, then deploy the refresher application:

[source, role="execute"]
----
envsubst < ~/lab-assets/oidc-info-secret.yml | oc apply -n openshift-pipelines -f -
oc apply -f ~/lab-assets/oidc-refresher-app.yml -n openshift-pipelines
----

* Use the following command to continuously monitor the refresher pod until it reaches the Running state:

[source, role="execute"]
----
watch -n 2 "oc get pods -n openshift-pipelines | awk '/^oidc-token-refresher/ { print; exit }'"
----

* Once the pod is running, the OIDC refresher is actively maintaining valid tokens for Tekton Chains.


== Step 5: Configure Tekton Chains

* By default, Tekton Chains expects static signing secrets.
* In this step, you will reconfigure Chains to use the RHTAS infrastructure and the continuously refreshed OIDC token instead.
* This allows Chains to perform keyless signing using short-lived identities, rather than long-lived keys.

=== Apply the Tekton Chains Configuration Patch

* Patch the Tekton configuration to point Chains at the RHTAS services and token source:

[source, role="execute"]
----
oc patch tektonconfig config -n openshift-pipelines --type=merge  --patch "$(cat ~/lab-assets/tekton-chains-patch.yml)"
----

* The patch updates Tekton Chains to integrate with RHTAS as follows:
. Points Tekton Chains to the local Rekor instance for transparency logging.
. Configures Chains to request signing certificates from the local Fulcio service.
. Instructs Chains to read the OIDC access token from the mounted file written by the OIDC Refresher App.
. Configures Chains to store signatures as OCI artifacts alongside the container image in the registry, rather than as separate text resources.

== Step 6: Verify Signing (Smoke Test)

* In this step, you will run a simple end-to-end smoke test to confirm that artifact signing is working as expected.
* You will manually trigger a Tekton Task that builds and pushes a container image. Because Tekton Chains was configured in Step 5, it should automatically:
. Detect the successful task completion.
. Sign the resulting image using the refreshed OIDC token.
. Upload the signature to Quay.
* This validates that keyless signing is correctly integrated into the pipeline.

=== Set Up Permissions for the Test Task

* Create a temporary service account with the permissions required to run buildah, which requires elevated SCCs.

[source, role="execute", subs="attributes"]
----
oc create sa chains-signing-image-tester -n tssc-app-ci
oc adm policy add-scc-to-user anyuid -z chains-signing-image-tester -n tssc-app-ci
oc adm policy add-scc-to-user privileged -z chains-signing-image-tester -n tssc-app-ci
oc secret link  chains-signing-image-tester tssc-image-registry-auth -n tssc-app-ci --for=mount
----

* Trigger the example Tekton Task that builds and pushes an image:

[source,role=“execute”]
----
oc create -f ~/lab-assets/example-image-sign.yml -n tssc-app-ci
----

* Tekton will execute the task, and upon successful completion, Tekton Chains will automatically sign the resulting image.
* Wait for the PipelineTask to reach the Succeeded status.

[source,role="execute"]
----
watch -n 2 "oc get taskrun -n tssc-app-ci"
----

* or you can switch to the OpenShift console, navigate to Pipelines -> Tasks and select the TaskRuns tab 

image::check_chains_task_run.png[Check Chains Task Run,align="center"]

=== Verify the Signature in Quay

* Log in to the Quay registry UI.
* Click the *Quay Console* tab in the Showroom and log in using:
* *Username*:

[source, role="execute", subs="attributes"]
----
{quay_admin_user}
----

* *Password*:

[source, role="execute", subs="attributes"]
----
{quay_admin_password}
----

* Navigate to the tssc/tekton-chains-test repository.

image::select_tekton_chains_image.png[select tekton_chains image,align="center"]

* Locate the image tag created by the task.
* You should see a shield icon next to the image tag as seen in the following screenshot. 
* This indicates that a valid Cosign signature is attached to the image.

image::Cosign_signature_shield.png[Cosign signature shield,align="center"]

=== Clean Up Temporary Permissions

Once verification is complete, remove the elevated permissions and delete the service account:

[source, role="execute", subs="attributes"]
----
oc adm policy remove-scc-from-user anyuid -z chains-signing-image-tester -n tssc-app-ci
oc adm policy remove-scc-from-user privileged -z chains-signing-image-tester -n tssc-app-ci
oc delete sa chains-signing-image-tester -n tssc-app-ci
----

===  Module 2 Summary

* In this module, you addressed the second customer challenge: “We cannot trust that our code and images were really produced by us, or that they haven’t been modified along the way.” 
* As a consultant, you learned how to deploy *Red Hat Trusted Artifact Signer (RHTAS)* and implement keyless signing for both code commits and container images, ensuring artifacts are cryptographically verifiable and protected from tampering.
* For customers, this means build integrity is no longer assumed — it is provable. They can verify who authored the code, which system built the image and whether the artifact has been altered since it was produced. 
* For technical sellers, this is the moment where the story resonates with customers: “This is how we prove your software really came from you and was not tampered with.”
* With identity and integrity established, the next challenge becomes: “How do we keep developers fast without compromising security?” 
* In Module 3, you will focus on developer workflows and show how *Red Hat Advanced Developer Suite (RHADS)* security guardrails are built into developer flows without slowing developers down.