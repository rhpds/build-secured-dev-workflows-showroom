= Module 2: Sign and Verify All Artifacts With *RHTAS* 

In Module 1, you established trust in what is inside your software. The next challenge customers face is: “How do we know these artifacts were really built by us and haven’t been tampered with?” They need assurance that both code commits and build artifacts originate from trusted sources—not rogue machines or compromised pipelines.

In this module, you will deploy Red Hat Trusted Artifact Signer (RHTAS) to establish the Root of Trust for the entire build system. Unlike "traditional" signing which uses long-lived static keys (which are a nightmare to rotate and secure), RHTAS uses Keyless Signing.
How Keyless Signing Works here:
1. Identity (Keycloak): We authenticate an entity (user or machine) via OIDC.
2. Certificate Authority (Fulcio): RHTAS issues a short-lived X.509 certificate bound to that OIDC identity.
3. Transparency Log (Rekor): The signature and the certificate are logged in an immutable ledger.
4. Verification: We trust the artifact not because we have a public key, but because we can cryptographically prove the certificate was valid at the time of signing and belongs to a trusted OIDC identity.


== 1: Configure the Machine Identity

Tekton Chains requires its own realm and client to sign images on behalf of the pipeline.
This isolates automated signing from human user identities and is considered best practice in customer deployments.

=== Step 1: Create tas-chains realm

If you skipped module 1, click the *RHBK Console* tab in the Showroom and log in to the RHBK console using the following details:
* *Username*: {keycloak_admin_user}
* *Password*: {keycloak_admin_password}
* After entering your credentials,click the *Sign In* button.

* In the *RHBK Console* click on the "Manage Realm" link in the left navigation menu, then click on the *Create realm* button.

image::create_tas_realm.png[Create Realm,align="center"]

* In the create realm pop up, enter the name *tas-chains* and click the *Create* button.

image::create_tas_chains_realm.png[Create TAS Chains realm,align="center"]

=== Step 2: Create tas-chains client

* Next you you will create a new client, click on the "Clients" link in the left navigation menu, then click on the *Create client* button.

image::create_client.png[Create Client,align="center"]

* In the Create Client view, under General setting, set the following:
. Client ID: trusted-artifact-signer
. Name: trusted-artifact-signer
* Then click Next

image::tas_client_general_settings.png[New Client General Settings,align="center"]

* Under Capability Config set the following:
. Client authentication: toggle to on
. standardflow: Make sure is ticked
. Service accounts roles: Tick
. Front channel logout: Scroll down and make sure is toggled on

* Switch to the service account roles tab
* Click the service-account-trusted-artifact-signer user link and provide the following:
. VerifyEmail: Toggle to on
. Email: trusted-artifact-signer@demo.redhat.com
. First name: Trusted
. Last name: Content
* The click on *Save*




WARNING: This is the most common failure point in RHTAS deployments. Fulcio requires the OIDC token to contain a verified email claim. If this is missing, certificate issuance fails.

[source,bash]
----
cat /etc/redhat-release
----
+ 
NOTE: The `bastion` system is Red Hat Enterprise Linux 9, and when you built the previous container, you used the UBI9 image. This means both the image and the container were built off the same Red Hat Enterprise Linux packages. 

. As we did previously in this lab, Use `buildah from` to pull down the Red Hat Enterprise Linux 8 UBI.

+
[source,bash]
----
buildah from registry.access.redhat.com/ubi8/ubi
----

NOTE: Because you already pulled one image named `ubi-working-container` this one is called `ubi-working-container-1`. 

[#prerequisites]
== Install Prerequisites

Now that you have a working container, you will use the same process as before installing all the prerequisites, changing config files, and manipulating the contents of this container to be in the desired state.

The software you will install is a JavaScript-based game that runs on a web browser. As before in the lab, use dnf to install software inside the container. 

. Use `buildah run` and install Apache (`httpd`) into the `ubi-working-container-1` container. 
+
[source,bash]
----
buildah run ubi-working-container-1 -- dnf -y install httpd
----

== Enable Service

The next thing to do is to use a systemctl to enable the service. The ubi-init provides full systemd service to the container.
This will start up any of the services that are enabled. 

. Enable the `httpd` service using `buildah run`

+
[source,bash]
----
buildah run ubi-working-container-1 -- systemctl enable httpd
----

NOTE: The UBI standard image doesn't have systemd installed on it by default. The `ubi-init` container image does include systemd. Plan accordingly to which image you use to build applications.  

== Explore Source Materials

A GitHub repository has already been synchronized to `/home/devops/clumsy-bird/` This repository contains the configurations for your application.

. Verify the repository is cloned inside the `/home/devops/` directory
+
[source,bash]
----
cd /home/devops/
----

+
[source,bash]
----
git clone https://github.com/ellisonleao/clumsy-bird
----
+
NOTE: The output states that the software has already been checked out. 
+
. Explore the JavaScript contents, index files, and everything else that we need for this web-based JavaScript software.
+
[source,bash,role=execute]
----
ls clumsy-bird
----

== Add Source Materials to Container

. Now that you have verified the source materials exist, you will put the software inside of my container image using the `buildah copy` command.
+
[source,bash]
----
buildah copy ubi-working-container-1 clumsy-bird /var/www/html
----

[#container]
== Enable Container in Background

In the previous section of this lab, you ran the game natively through interactive mode. Because you are now building a web application you will need to run the container in the background and access it through a web address. 

. Execute `buildah config` to specify a port and initialize the container. 

+
[source,bash]
----
buildah config --port 80 --cmd "/usr/sbin/init" ubi-working-container-1
----

NOTE: The command makes a configuration change to this container. I'm configuring this container to accept connections to its port 80. When the container starts up, it should run the init command, which, in this case, is going to be the Apache daemon right from earlier when I enabled it.

== Commit Container and Deploy

. Now that we have a container in a working configured state, it is time to make that permanent by committing it to a container image called `clumsy-bird`
+
[source,bash]
----
buildah commit ubi-working-container-1 clumsy-bird
----

. Verify that the image was created with `podman`
+
[source,bash]
----
podman images
----
+
. Run the container Now it's time to run the container. 
+
[source,bash]
----
podman run -d -p 8500:80 clumsy-bird
----

== Verify Application

Verify that the application is running by navigating to

http://bastion.{guid}.example.opentlc.com:8500

