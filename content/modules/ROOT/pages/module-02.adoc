= Module 2: Sign and Verify All Artifacts With *RHTAS* 

In Module 1, you established trust in what is inside your software. The next challenge customers face is: “How do we know these artifacts were really built by us and haven’t been tampered with?” They need assurance that both code commits and build artifacts originate from trusted sources—not rogue machines or compromised pipelines.

In this module, you will deploy Red Hat Trusted Artifact Signer (RHTAS) to establish the Root of Trust for the entire build system. Unlike "traditional" signing which uses long-lived static keys (which are a nightmare to rotate and secure), RHTAS uses Keyless Signing.
How Keyless Signing Works here:
1. Identity (Keycloak): We authenticate an entity (user or machine) via OIDC.
2. Certificate Authority (Fulcio): RHTAS issues a short-lived X.509 certificate bound to that OIDC identity.
3. Transparency Log (Rekor): The signature and the certificate are logged in an immutable ledger.
4. Verification: We trust the artifact not because we have a public key, but because we can cryptographically prove the certificate was valid at the time of signing and belongs to a trusted OIDC identity.


== 1: Configure the Machine Identity

Tekton Chains requires its own realm and client to sign images on behalf of the pipeline.
This isolates automated signing from human user identities and is considered best practice in customer deployments.

=== Step 1: Create tas-chains realm and tas client

* If you skipped module 1:
* Click the *RHBK Console* tab in the Showroom and log in using:
. *Username*:
[source, role="execute", subs="attributes"]
----
{keycloak_admin_user}
----
. *Password*:
[source, role="execute", subs="attributes"]
----
{keycloak_admin_password}
----
* After entering your credentials,click *Sign In* .

* In the *RHBK Console*, click *Manage Realm*  in the left navigation menu.
* Click the *Create realm* button.

image::create_tas_realm.png[Create Realm,align="center"]

* In the *Create realm* pop up, enter the name *tas-chains* and click *Create*.

image::create_tas_chains_realm.png[Create TAS Chains realm,align="center"]

* Next you you will create a new client, in the left navigation menu, click *Clients*, then click *Create client*.

image::create_client.png[Create Client,align="center"]

* In the *General setting* page:
. Set the *Client ID* to *trusted-artifact-signer*
. Click *Next*.

image::tas_client_general_settings.png[New Client General Settings,align="center"]

* Under *Capability Config*, set:
. *Client authentication*: toggle on
. *Standard flow*: make sure this checkbox is ticked
. *Service accounts* roles: Tick this checkbox
* Then click *Next*.

image::tas_client_capability_config.png[New Client Capability Config,align="center"]

* Under *Login Settings*, leave the default values as they are.
* Click *Save*.

image::tas_client_login_settings.png[New Client Login Settings,align="center"]

* Scroll down to *Logout Settings*:
. Make sure *Front channel logout* is toggled on.
. Click *Save*.

image::tas_client_logout_settings.png[New Client Logout Settings,align="center"]

* Next click the *Service account roles* tab 
* Click the *service-account-trusted-artifact-signer* link

image::tas_client_service_account_roles.png[New Client Service Account Roles,align="center"]

* Set the following attributes:
. *Email Verified*: toggle on
. *Email*: 
[source, role="execute", subs="attributes"]
----
trusted-artifact-signer@demo.redhat.com
----
. *First name*: Trusted
. *Last name*: Content
* The click *Save*

image::tas_client_service_account_details.png[New Client Service Account Roles,align="center"]

WARNING: This is the most common failure point in RHTAS deployments. Fulcio requires the OIDC token to contain a verified email claim. If this is missing, certificate issuance fails.

=== Step 2: Configure Developer Identity for Commit Signing

* Developers need a trusted identity to sign *Git* commits using *RHTAS*.
* This identity is separate from Tekton’s machine identity you configured in the last step and is configured in the existing sso realm.
* The client you create here enables OAuth-based authentication for developers performing commit signing.

* In the *RHBK Console*, click *Manage Realm* in the left navigation menu.
* Select the *sso* realm.

image::tas_sso_realm.png[TAS SSO Realm,align="center"]

* Navigate to *Clients* in the left menu and click *Create client*.

image::tas_create_client.png[TAS Create Client,align="center"]

* In the *General setting* page:
. Set the *Client ID* to:
[source, role="execute", subs="attributes"]
----
*trusted-artifact-signer*
----
. Click *Next*.

image::tas_client_general_settings.png[New Client General Settings,align="center"]

* Under Capability Config set:
. *Standard flow*: Make sure this checkbox is ticked.
. *Direct Access Grants*: Tick this checkbox.
* Then click *Next*.

image::tas_commit_client_capability_config.png[New Client Capability Config,align="center"]

* In the *Login Settings* page, add the following *Valid Direct URIs*:
. Add the first URI: 
[source, role="execute", subs="attributes"]
----
*urn:ietf:wg:oauth:2.0:oob*
----
. Click *Add valid redirect URIs*, then input:
[source, role="execute", subs="attributes"]
----
*
----
* Click *Save*
* This allows tools like *RHTAS* to complete the OAuth authentication flow.

image::tas_commit_client_client_login_settings.png[New Client Login Settings,align="center"]

* Now scroll down to the *Logout settings* section and set the *Front channel logout* toggle to *Off*. 
* Then click *Save*

image::tas_commit_client_logout_settings.png[New Client Logout Settings,align="center"]


=== Step 3: Deploy the RHTAS Instance

Now that both machine and developer identities are configured, you can deploy the RHTAS components (Fulcio, Rekor, Trillian and TUF) using the Custom Resource.

* Run the following command to apply the *RHTAS* Instance CR:

[source, role="execute"]
----
cat << 'EOF' >> ~/.bashrc
export TAS_CHAINS_CLIENT_ID={tas_chains_client_id}
export TAS_CHAINS_REALM={tas_chains_realm}
export TAS_SSO_REALM={tas_sso_realm}
EOF
source ~/.bashrc
envsubst < ~/lab-assets/tas-instance.yml | oc apply -n tssc-tas -f -
----

* Verify Deployment Readiness
. Switch to the *OpenShift console*
. Navigate to *Workloads → Pods*
. Change the project/namespace to *tssc-tas*
. Wait until the tuf pod is in Running state.

image::tas_verify_deploy.png[Verify RHTAS deploy,align="center"]

== Step 4: Deploy The OIDC Refresher App 

* In this step you will deploy a small helper application that continuously refreshes the OIDC token required for signing.

===  Why is the OIDC Refresher App needed?

* Fulcio issues short-lived certificates based on OIDC tokens.
* For security reasons, these tokens typically expire within 5 minute
* However, a CI/CD pipeline (such as a Tekton build) may run for 20 minutes or more before reaching the Sign Image step.
* If Tekton Chains attempts to sign an image using the token obtained at pipeline start, that token will almost certainly have expired.
* To solve this, you will deploy the OIDC Refresher App which does the following:
. Authenticates with Keycloak using the trusted-artifact-signer client credentials you created in Step 1.
. Fetches a fresh access token.
. Writes the token into a Kubernetes Secret named oidc-token in the openshift-pipelines namespace.
. Refreshes the token every 2 minutes, ensuring Tekton always signs using a valid identity.

===  Deploy OIDC Refresher App

* First, retrieve the Keycloak admin credentials from the keycloak-initial-admin secret in the tssc-keycloak namespace:

[source, role="execute"]
export keycloak_admin_user=$(oc get secret keycloak-initial-admin -n tssc-keycloak -o jsonpath='{.data.username}' | base64 -d)
export keycloak_admin_password=$(oc get secret keycloak-initial-admin -n tssc-keycloak -o jsonpath='{.data.password}' | base64 -d)
----

* Next, use the credentials to request an admin access token:

[source, role="execute"]
----
KEYCLOAK_ACCESS_TOKEN=$(curl -s -X POST "${KEYCLOAK_URL}/realms/master/protocol/openid-connect/token" \
-H "Content-Type: application/x-www-form-urlencoded" \
-d "client_id=admin-cli" \
-d "username=$keycloak_admin_user" \
-d "password=$keycloak_admin_password" \
-d "grant_type=password" | jq -r '.access_token')
----

* Next, retrieve the client secret for the trusted-artifact-signer client from the tas-chains realm:

[source, role="execute"]
----
export TAS_CHAINS_CLIENT_SECRET=$(curl -s -X GET "${KEYCLOAK_URL}/admin/realms/$TAS_CHAINS_REALM/clients?clientId=$TAS_CHAINS_CLIENT_ID" \
  -H "Authorization: Bearer $KEYCLOAK_ACCESS_TOKEN" | jq -r '.[0].secret')
----

* Finally, create the Kubernetes Secret containing the OIDC configuration, then deploy the refresher application:

[source, role="execute"]
----
envsubst < ~/lab-assets/oidc-info-secret.yml | oc apply -n openshift-pipelines -f -
oc apply -f ~/lab-assets/oidc-refresher-app.yml -n openshift-pipelines
----

* Use the following command to continuously monitor the refresher pod until it reaches the Running state:

[source, role="execute"]
----
watch -n 2 "oc get pods -n openshift-pipelines | awk '/^oidc-token-refresher/ { print; exit }'"
----

* Once the pod is running, the OIDC refresher is actively maintaining valid tokens for Tekton Chains.


== Step 5: Configure Tekton Chains

* By default, Tekton Chains expects static signing secrets.
* In this step, you will reconfigure Chains to use the RHTAS infrastructure and the continuously refreshed OIDC token instead.
* This allows Chains to perform keyless signing using short-lived identities, rather than long-lived keys.

=== Apply the Tekton Chains Configuration Patch

* Patch the Tekton configuration to point Chains at the RHTAS services and token source:

[source,role=“execute”]
----
oc patch tektonconfig config -n openshift-pipelines --type=merge  --patch "$(cat ~/lab-assets/tekton-chains-patch.yml)"
----

* The patch updates Tekton Chains to integrate with RHTAS as follows:
. Points Tekton Chains to the local Rekor instance for transparency logging.
. Configures Chains to request signing certificates from the local Fulcio service.
. Instructs Chains to read the OIDC access token from the mounted file written by the OIDC Refresher App.
. Configures Chains to store signatures as OCI artifacts alongside the container image in the registry, rather than as separate text resources.

== Step 6: Verify Signing (Smoke Test)

* In this step, you will run a simple end-to-end smoke test to confirm that artifact signing is working as expected.
* You will manually trigger a Tekton Task that builds and pushes a container image. Because Tekton Chains was configured in Step 5, it should automatically:
. Detect the successful task completion.
. Sign the resulting image using the refreshed OIDC token.
. Upload the signature to Quay.
* This validates that keyless signing is correctly integrated into the pipeline.

=== Set Up Permissions for the Test Task

* Create a temporary service account with the permissions required to run buildah, which requires elevated SCCs.

[source,role=“execute”]
----
oc create sa chains-signing-image-tester -n tssc-app-ci
oc adm policy add-scc-to-user anyuid -z chains-signing-image-tester -n tssc-app-ci
oc adm policy add-scc-to-user privileged -z chains-signing-image-tester -n tssc-app-ci
oc secret link  chains-signing-image-tester tssc-image-registry-auth -n tssc-app-ci --for=mount
----

* Trigger the example Tekton Task that builds and pushes an image:
[source,role=“execute”]
----
oc create -f ~/lab-assets/example-image-sign.yml -n tssc-app-ci
----

* Tekton will execute the task, and upon successful completion, Tekton Chains will automatically sign the resulting image.
* Wait for the PipelineTask to reach the Succeeded status.

[source,role="execute"]
----
watch -n 2 "oc get taskrun -n tssc-app-ci"
----

* or you can switch to the OpenShift console, navigate to Pipelines -> Tasks and select the TaskRuns tab 

image::check_chains_task_run.png[Check Chains Task Run,align="center"]